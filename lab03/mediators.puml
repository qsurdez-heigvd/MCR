@startuml

' STATIC
' Generated by CTP - https://github.com/samuelroland/ctp

' Style
hide empty members
hide circle
skinparam classAttributeIconSize 0


' Additions

' REMOVE

' ENDSTATIC

class AggressiveMediator {
	+ handleResourceFound(resource: Resource): void
	+ handlePredatorFound(predator: Predator): void
	+ handlePredatorDeath(predator: Predator): void
	+ predatorStillNearby(ant: Ant): void
	+ handleUpdateGatherer(gatherer: Gatherer): void
	+ handleUpdateScout(scout: Scout): void
	+ handleUpdateSoldier(soldier: Soldier): void
	+ getRadiusResource(): int
	+ getRadiusToPredator(): int
	+ getRadiusToFlee(): int
	+ getThresholdToCreateAnt(): int
	+ getRadiusPredatorToPrey(): int
	+ stepToSpawnResource(): int
	+ stepToSpawnPredator(): int
	+ handleDeath(): void
}

class BalancedMediator {
	+ handleUpdateGatherer(gatherer: Gatherer): void
	+ handleUpdateSoldier(soldier: Soldier): void
	+ getRadiusResource(): int
	+ getRadiusToPredator(): int
	+ getRadiusToFlee(): int
	+ getThresholdToCreateAnt(): int
	+ getRadiusPredatorToPrey(): int
	+ stepToSpawnResource(): int
	+ stepToSpawnPredator(): int
}


class ExploreMediator {
	+ handleUpdateGatherer(gatherer: Gatherer): void
	+ handleUpdateSoldier(soldier: Soldier): void
	+ addAnt(): void
	+ getRadiusToPredator(): int
	+ getRadiusToFlee(): int
	+ getThresholdToCreateAnt(): int
	+ getRadiusPredatorToPrey(): int
	+ stepToSpawnResource(): int
	+ getRadiusResource(): int
	+ stepToSpawnPredator(): int
}


abstract class Mediator {
	# targets: HashMap<Entity,Entity>
	# objectives: HashMap<Entity,AbstractColleague>
	# strategies: HashMap<Entity,MovementStrategy>
	# gatherers: LinkedList<Gatherer>
	# soldiers: LinkedList<Soldier>
	# scouts: LinkedList<Scout>
	# resources: LinkedList<Resource>
	# predators: LinkedList<Predator>
	# resourcesFound: LinkedList<Resource>
	# predatorsFound: LinkedList<Predator>
	# hub: Colony
	# random: Random
	# stepFromLastResourceSpawn: int
	# stepFromLastPredatorSpawn: int
	- simulationTime: Timer
	# toRemove: LinkedList<AbstractColleague>
	- displayer: SimulationDisplayer
	+ {abstract}handleUpdateGatherer(gatherer: Gatherer): void
	+ {abstract}getRadiusResource(): int
	+ {abstract}getRadiusToPredator(): int
	+ {abstract}getRadiusToFlee(): int
	+ {abstract}getThresholdToCreateAnt(): int
	+ {abstract}getRadiusPredatorToPrey(): int
	+ {abstract}stepToSpawnPredator(): int
	+ {abstract}handleUpdateSoldier(soldier: Soldier): void
	+ handleUpdatePredator(predator: Predator): void
	+ handleUpdateScout(scout: Scout): void
	+ getNbScouts(): int
	+ getNbGatherers(): int
	+ getNbSoldiers(): int
	+ getNbPredators(): int
	+ getTarget(entity: Entity): Entity
	+ checkForNearbyResources(scout: Ant): void
	+ handleResourceFound(resource: Resource): void
	+ checkForNearbyPredators(ant: Ant): void
	+ handlePredatorFound(predator: Predator): void
	+ predatorStillNearby(ant: Ant): void
	+ handleObjectiveReached(ant: Ant): void
	+ countNbTimesColleagueInObjectivesHashMap(\n\t abstractColleague: AbstractColleague): int
	+ nextTurn(): void
	+ addAnt(): void
	+ checkForNearbyPreys(predator: Predator): void
	+ handleResourceDepleted(resource: Resource): void
	+ handleAntDeath(ant: Ant): void
	+ handlePredatorDeath(predator: Predator): void
	+ withinRange(from: AbstractColleague, to: AbstractColleague, range: int): boolean
	+ entityAttacked(entity: Entity): void
	+ display(): void
	+ getAnts(): List<Ant>
	+ checkCollision(newPosition: Vector2, entity: AbstractColleague): boolean
	+ {abstract}stepToSpawnResource(): int
	+ spawnResource(): void
	+ spawnPredator(): void
	+ handleDeath(): void
	+ getObjective(entity: Entity): AbstractColleague
	+ finish(): void
}





Mediator <|-- AggressiveMediator

Mediator <|-- BalancedMediator


Mediator <|-- ExploreMediator

@enduml
